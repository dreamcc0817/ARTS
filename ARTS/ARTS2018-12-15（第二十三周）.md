# Algorithm
#####  <br>
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```java
class Solution {
    public void moveZeroes(int[] nums) {
		int len  = nums.length;
		for (int i = 0; i < len; i++) {
			if(nums[i]==0){
				for (int j = i; j < nums.length - 1; j++) {
					nums[j] = nums[j+1];
				}
				nums[nums.length - 1] = 0;
				i--;
				len--;
			}
		}
    }
}
```

# Review

文章标题：chapter1 introduction<br>
文章来源：java_concurrency_in_practice<br>

点评：操作系统逐渐可以一次性的执行多个程序，在一个进程中独立的运行一个程序：通过系统分配资源（内存， 文件句柄，安全策略）来独立执行程序。如果进程间需要通信，需要过原始的机制来通信：socket，signal handlers，share memory，semaphores，file。<br>
几个推动性的因素导致了操作系统的开发，使得多个程序可以同时运行：<br>
资源的利用。程序有时候不得不为一些输入输出操作停止执行，在这个等待的期间无法进行任何的工作，没有一点用处。多线程可以使这个等待的时间让另一个程序更加有效的去运行。<br>
公平性。多个用户和程序对计算机资源有相同的需求，让他们通过更加的时间片来共享计算机，这比结束一个程序后才开始下一个程序更加可取。<br>
便捷性。写一个程序，让他们各自执行一个简单任务并且互相通信要比写一个能完成整个任务的程序更加容易和令人满意。
在早期的分时共享系统中，每一个进程都是一个虚拟的冯诺依曼。它拥有一个内存空间去储存指令和数据，根据机器语言顺序的执行指令，并且通过操作系统I/O原语与外部通信。对于每一条指令都有下一条指令的明确定义，并根据程序中的指令集来进行流程的控制。现在所有广泛使用的编程语言都遵循这个顺序的编程模型，其中语言规范明确定义了在一个给定动作完成后， 下一个动作是什么。<br>
这个顺序模型是直观的，自然的，符合人类的工作习惯：每次只做一件事情，顺序执行。起床，穿上睡衣，下楼然后开始喝茶。在编程语言中，真实世界的每一个动作能够抽象成一个规则的动作系列，打开茶柜，选择一定量的茶，打开灶台的开关，看是否有足够的水去泡茶，如果不够就加点水，把茶壶放在炉子上，打开路子，等待水的沸腾等等。最后一步--等待水沸腾--这也引入了异步这个要点。当水在加热的时候，你可以选择做什么--等待，或者开始准备吐司面包（另一个异步任务），还可以取一份报纸看，同时仍然要记得煮开水的壶马上就会需要你的关注。开水喝吐司面包的生产者知道他们的产品通常在异步的情况下使用，所以在任务结束的时候，他们会提高信号的音量。找到顺序和一部之间最好的平衡，通常是那些高效率人士的一个特点--对于程序来说也是如此。<br>
相同的关注点（资源利用，公平性，有效性）不仅促进了进程的发展，也同时存进了线程的发展。多线程允许程序的多个流在一个进程中和平共处。多线程可以分享进程重点资源比如：内存， 和文件句柄，但是每个线程都有自己的program counter，stack and local variables。线程还未利用多处理器系统上的硬件并行性提供了一个自然的分解，同一个程序中的多个线程可以在多个cpu上同时调度。<br>
多线程有时候也可以被称为轻量级的进程，并且大多数现代操作系统把线程作为时序调度的基本单元，而不是进程。在没有明确协调的情况下，线程互相同时或异步地执行。线程共享他们的进程的内存地址，一个进程内的所有线程可以访问来自同一个堆的变量和对象，这对于进程间通信机制来说，实现了数据共享。但是没有明确的同步机制去访问一个共享数据，一个线程可能会修改其他线程正在使用的数据，产生意外的结果。<br>

# Tip
每周一个linux命令：

只列出文件下的子目录

命令：ls -F /opt/soft |grep /$  
# Share Linux进程（一）
Linux是一个多处理的操作系统，进程是独立的任务，每个进程都有自己的权限和职责。

在进程的生命周期中，它将使用许多系统资源。它将使用系统中的cpu来运行它的指令，并使用系统的物理内存来保存它和它的数据。它将在文件系统中打开和使用文件，并可能直接或间接地使用系统中的物理设备。Linux必须跟踪进程本身和它所拥有的系统资源，以便能够公平地管理它和系统中的其他进程。如果一个进程独占了系统的大部分物理内存或cpu，这对系统中的其他进程是不公平的。

系统中最宝贵的资源是CPU，通常只有一个CPU。Linux是一个多处理操作系统，它的目标是在系统中的每个CPU上始终运行一个进程，以最大限度地提高CPU利用率。如果进程多于CPU(通常是这样)，那么其他进程必须等待CPU空闲后才能运行。多处理是一个简单的概念;一个进程被执行，直到它必须等待，通常是等待某个系统资源;当它拥有这个资源时，它可能会再次运行。在单处理系统(例如DOS)中，CPU会处于空闲状态，等待时间会被浪费。在多处理系统中，许多进程同时保存在内存中。每当一个进程必须等待时，操作系统就会将CPU从该进程中取出，并将其交给另一个更值得等待的进程。调度程序选择下一步运行哪个进程最合适，Linux使用许多调度策略来确保公平性。

Linux支持许多不同的可执行文件格式，ELF是一种，Java是另一种，这些格式必须透明地管理，系统的共享库的进程也必须如此。
###### Linux进程类型：

前台类型（交互式进程）：这些进程由控制台初始化和控制。换句话说，需要用户连接到系统中进行操作，他们不是作为系统功能/服务随系统自动启动。

后台进程（非交互式进程/自动化进程）：这些进程不需要用户连接到系统中进行操作。

###### 进程状态

![image](https://dn-linuxcn.qbox.me/data/attachment/album/201704/27/093035wd0ly8pppjc0fo8o.png)

###### 


